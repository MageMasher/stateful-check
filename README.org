#+TITLE: stateful-check

A [[http://clojure.org][Clojure]] library designed to help with testing stateful systems with
[[https://github.com/clojure/test.check/][test.check]].

#+BEGIN_HTML
<a href="http://clojars.org/org.clojars.czan/stateful-check">
  <img src="http://clojars.org/org.clojars.czan/stateful-check/latest-version.svg"
       alt="Clojars Project">
</a>
#+END_HTML

* Example

As an example, let's test a mutable queue (a ~PersistentQueue~ in an
atom). Our queue will have three operations: ~new~, ~push~ and
~pop~. Before we get started, though, let's import some things which
we'll need later.

#+BEGIN_SRC clojure :results silent :exports code
  (require '[clojure.test.check.generators :as gen]
           '[clojure.test.check :refer [quick-check]]
           '[stateful-check.core :refer [reality-matches-model? print-test-results]])

#+END_SRC

** Defining

*** ~new-queue~

The implementation for the ~new-queue~ function is quite simple:

#+BEGIN_SRC clojure :results silent :exports code
  (defn new-queue []
    (atom clojure.lang.PersistentQueue/EMPTY))
#+END_SRC

In order to use it with ~stateful-check~ we also need to model its
abstract semantics:

#+BEGIN_SRC clojure :results silent :exports code
  (def new-queue-specification
    {:next-state (fn [state _ result]
                   {:queue result, :elements []})
     :real/command #'new-queue})
#+END_SRC

This specification contains two elements:

- ~:real/command~ is a function which will be called when running the
  test. It performs an action on the real state, and is the thing the
  specification is modelling.

- ~:next-state~ denotes the effect that running this command will have
  on the abstract state. In this case running the ~new-queue~ function
  will initialise the abstract state. ~:element~ is set to the empty
  vector because our queue starts off empty. ~:queue~ is set to the
  result of calling the ~:real/command~ function to store it for later
  operations.

In this instance the ~:next-state~ function is called when performing
both the abstract and the real evaluation. This means that ~:result~
could be an abstract value, and thus cannot be operated on directly in
~:next-state~. When an abstract value is used as an argument to a
later command, however, it will be replaced by its corresponding
concrete value (as can be seen below, where ~:queue~ is used as an
argument to ~push-queue~ and ~pop-queue~).

*** ~push-queue~

Similarly, ~push-queue~ is fairly simple to implement.

#+BEGIN_SRC clojure :results silent :exports code
  (defn push-queue [queue val]
    (swap! queue conj val)
    nil)
#+END_SRC

Then its abstract semantics:

#+BEGIN_SRC clojure :results silent :exports code
  (def push-queue-specification
    {:model/args (fn [state]
                   (gen/tuple (gen/return (:queue state))
                              gen/nat))
     :model/precondition (fn [state _] (:queue state))
     :real/command #'push-queue
     :next-state (fn [state [_ val] _]
                   (assoc state
                     :elements (conj (:elements state) val)))})
#+END_SRC

This specification has two additional elements over
~new-queue-specification~:

- ~:model/args~ specifies a function which will provide a generator to
  generate arguments for ~push-queue~. In this case we will attempt to
  push a natural number (~gen/nat~) into the queue under test (which
  we have stored in ~(:queue state)~)

- ~:model/precondition~ specifies whether this command is valid to
  run. By inspecting ~state~ and the generated arguments we may be
  able to determine that this is an invalid call. In this case: if we
  have not allocated a queue (using ~new-queue~) then it is invalid to
  try to push.

In addition to these, we can see that ~:next-state~ simply adds the
command to the end of the ~:elements~ vector in the ~state~ map.

*** ~pop-queue~

Lastly, ~pop-queue~:

#+BEGIN_SRC clojure :results silent :exports code
  (defn pop-queue [queue]
    (let [val (peek @queue)]
      (swap! queue pop)))

  (def pop-queue-specification
    {:model/args (fn [state]
                   (gen/return [(:queue state)]))
     :model/precondition (fn [state _]
                           (not (empty? (:elements state))))
     :real/command #'pop-queue
     :next-state (fn [state _ _]
                   (assoc state
                     :elements (vec (next (:elements state)))))
     :real/postcondition (fn [state _ val]
                           (= val (first (:elements state))))})
#+END_SRC

This specification has one more element from ~push-queue-specification~:

- ~:real/postcondition~ determines whether the result of performing
  this action correctly matches the expectation (from the abstract
  state). In our case: we expect the value returned by ~pop-queue~ to
  be the first value in the ~:elements~ vector.

** Running

Now we want to run our specification. In order to do this we first
need to assemble each of our command specifications into a full model
specification.

#+BEGIN_SRC clojure :results silent :exports code
  (def queue-spec
    {:commands {:new new-queue-specification
                :push push-queue-specification
                :pop pop-queue-specification}
     :model/generate-command (fn [state]
                               (if (nil? state)
                                 (gen/return :new)
                                 (gen/elements [:push :pop])))})
#+END_SRC

The ~:commands~ key just contains a map of each command spec we are
using for this model. ~:model/generate-command~ is a function from the
abstract state to a generator which will generate a new command.

Let's see what happens when we run this specification:

#+BEGIN_SRC clojure :results result
  (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645)
  ;; {:result false, :seed 1417059242645, :failing-size 5, :num-tests 6, :fail [[[#<0> (:new)] [#<1> (:push #<0> 4)] [#<2> (:push #<0> 2)] [#<3> (:pop #<0>)]]], :shrunk {:total-nodes-visited 5, :depth 1, :result false, :smallest [[[#<0> (:new)] [#<1> (:push #<0> 4)] [#<3> (:pop #<0>)]]]}}
#+END_SRC

Whoops! It failed! We must have a bug somewhere. Let's see if we can see that output in a nicer form.

#+BEGIN_SRC clojure :results output
  (print-test-results queue-spec (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645))
  ;; Failing test case:
  ;;    #<0> = (:new)     ;=> #<Atom@6dce3a19: #<PersistentQueue clojure.lang.PersistentQueue@1>>
  ;;    #<1> = (:push #<0> 4)     ;=> nil
  ;;    #<2> = (:push #<0> 2)     ;=> nil
  ;;    #<3> = (:pop #<0>)        ;=> #<PersistentQueue clojure.lang.PersistentQueue@21>
  ;;    !! Postcondition failed !!
  ;; Shrunk:
  ;;    #<0> = (:new)     ;=> #<Atom@7e4877a0: #<PersistentQueue clojure.lang.PersistentQueue@1>>
  ;;    #<1> = (:push #<0> 0)     ;=> nil
  ;;    #<3> = (:pop #<0>)        ;=> #<PersistentQueue clojure.lang.PersistentQueue@1>
  ;;    !! Postcondition failed !!
#+END_SRC

Okay, we seem to have an error when we create a queue, then push a
value into it, then pop the value back out. So it could be a problem
with any of our operations.

Looking at the return value of the ~:pop~ step, though, we can see
that it's returning the wrong thing! It's returning us a queue, not a
value from the queue. We have a bug!

So, let's fix our error.

#+BEGIN_SRC clojure :results silent :exports code
  (defn pop-queue [queue]
    (let [val (peek @queue)]
      (swap! queue pop)
      val))
#+END_SRC

Now let's try running our tests again.

#+BEGIN_SRC clojure :results result
  (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645)
  ;; {:result true, :num-tests 100, :seed 1417059242645}
#+END_SRC

Success!

* Specifications

When reading a ~stateful-check~ specification there are two main types
of keys: ~model~ and ~real~.

- ~model~ keys are ones which are keywords in the ~model~ namespace
  (that is, ~:model/X~). They deal exclusively with the abstract state
  of the system, and are only run during command generation. They
  should have no side effects. They are always provided with symbolic
  values representing the results of real commands.

- ~real~ keys are ones which are keywords in the ~real~ namespace
  (that is, ~:real/X~). They deal with the real state of the system
  and are only run during command execution. They can perform any
  side-effecting operation and are given the actual results of
  previous commands.

The distinction between the two types of keys is very important. While
values can flow from the ~model~ functions to the ~real~ functions,
they cannot flow the other way. ~model~ functions are only given
placeholders representing ~real~ values.

** Model specifications

A model specification is a map with two required keys:

- ~:commands~ is a map with values which are command specifications
  (see below). This map contains all the operations which
  ~stateful-check~ knows how to perform. The keys to this map are
  opaque to ~stateful-check~, but are used in the
  ~:model/generate-command~ function (and must be printable).

- ~:model/generate-command~ is a function from an abstract state to a
  generator. In the interests of efficiency this function should
  attempt to create a generator which will only produce valid
  commands. A generated command is a key into the ~:commands~ map.

There are six optional keys:

- ~:model/initial-state~ is a function to generate the initial state
  of the abstract system. If the spec also has a ~:real/setup~
  function then ~:model/initial-state~ will be provided with an
  argument which is a symbolic value representing the return value of
  the ~:real/setup~ function. If no ~:real/setup~ function can be
  found then ~:model/initial-state~ will be called with no arguments.

- ~:real/initial-state~ is the same as the ~:model/initial-state~
  function, except for the concrete command state. If a ~:real/setup~
  key exists then ~:real/initial-state~ will be passed the return
  value of the ~:real/setup~ function. Otherwise, it will be called
  with no arguments.

- ~:initial-state~ is a shortcut for defining both
  ~:model/initial-state~ and ~:real/initial-state~ in instances where
  the difference is irrelevant. It will be provided with either an
  abstract value or a concrete value, depending on when it is
  run. Precedence is given to the namespaced keys if they are present.

- ~:real/setup~ is a function of zero arguments which is called prior
  to any commands being run in an execution. Its return value is
  passed to the ~:real/initial-state~ function, and is available in
  symbolic form to the ~:model/initial-state~ function.

- ~:real/cleanup~ is a function of the state which can perform any
  cleanup operations required. Its return value is ignored.

- ~:real/postcondition~ is a function of the state which can perform
  general postcondition checking. This is run after each call to
  ~:real/next-state~ with the result of the transformation. This is
  intended to aid in testing things which must always be true, to
  avoid having to repeat them in each postcondition.

** Command specifications

A command specification is a map with one required key:

- ~:real/command~ is a function to perform an operation on the real
  system.

There are six optional keys:

- ~:model/args~ is a function from state to a generator which will
  generate a vector of arguments.

- ~:model/precondition~ is a function from the state and the generated
  arguments to a value indicating whether this command is valid to run
  at this stage. If the return value of this function is falsey then
  this command is considered invalid and this sequence will not be
  run.

- ~:model/next-state~ is a function from the state, the arguments and
  an abstract result placeholder to the next state for the system.

- ~:real/next-state~ is a function from the state, the arguments and a
  concrete result to the next state for the system.

- ~:next-state~ is a shortcut for specifying ~:model/next-state~ and
  ~:real/next-state~ to be the same function. Precedence is given to
  the namespaced keys if they are present.

- ~:real/postcondition~ is a function from the state, the arguments
  and a concrete result to a value indicating whether this command
  succeeded. If the return value of this function is falsey then this
  command (and hence this sequence of commands) is considered to be
  failed.

If any of these functions throw an exception it will provoke a test
failure.

The ~model~ namespaced keys are given an abstract state object. Any
results of commands will be opaque and abstract and the real state of
the system cannot be queried.

The ~real~ namespaced keys are given an actual, concrete state of the
system. They are only called during the actual execution of the
commands. Any results of commands will be the actual results of
running those commands.

* Related work

- [[https://github.com/clojure/test.check/][test.check]] (generative testing for Clojure)
- [[http://www.quviq.com/index.html][QuviQ Quickcheck]] (commercial generative testing for Erlang)
- [[http://proper.softlab.ntua.gr/index.html][PropEr]] (open source generative testing for Erlang)

* Future work

- race-condition debugging (parallel test cases)

* License

Copyright © 2014 Carlo Zancanaro

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
