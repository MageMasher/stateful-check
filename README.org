#+TITLE: stateful-check

A [[http://clojure.org][Clojure]] library designed to help with testing stateful systems with
[[https://github.com/clojure/test.check/][test.check]].

#+BEGIN_HTML
<a href="http://clojars.org/org.clojars.czan/stateful-check">
  <img src="http://clojars.org/org.clojars.czan/stateful-check/latest-version.svg"
       alt="Clojars Project">
</a>
#+END_HTML

* Example

As an example, let's test a mutable queue (a ~PersistentQueue~ in an
atom). Our queue will have three operations: ~new~, ~push~ and
~pop~. Before we get started, though, let's import some things which
we'll need later.

#+BEGIN_SRC clojure :results silent :exports code
  (require '[clojure.test.check.generators :as gen]
           '[clojure.test.check :refer [quick-check]]
           '[stateful-check.core :refer [reality-matches-model? print-test-results]])

#+END_SRC

** Defining

*** ~new-queue~

The implementation for the ~new-queue~ function is quite simple:

#+BEGIN_SRC clojure :results silent :exports code
  (defn new-queue []
    (atom clojure.lang.PersistentQueue/EMPTY))
#+END_SRC

In order to use it with ~stateful-check~ we also need to model its
abstract semantics:

#+BEGIN_SRC clojure :results silent :exports code
  (def new-queue-specification
    {:next-state (fn [state _ result]
                   {:queue result, :elements []})
     :real/command #'new-queue})
#+END_SRC

This specification contains two elements:

- ~:real/command~ is a function which will be called when running the
  test. It performs an action on the real state, and is the thing the
  specification is modelling.

- ~:next-state~ denotes the effect that running this command will have
  on the abstract state. In this case running the ~new-queue~ function
  will initialise the abstract state. ~:element~ is set to the empty
  vector because our queue starts off empty. ~:queue~ is set to the
  result of calling the ~:real/command~ function to store it for later
  operations.

In this instance the ~:next-state~ function is called when performing
both the abstract and the real evaluation. This means that ~:result~
could be an abstract value, and thus cannot be operated on directly in
~:next-state~. When an abstract value is used as an argument to a
later command, however, it will be replaced by its corresponding
concrete value (as can be seen below, where ~:queue~ is used as an
argument to ~push-queue~ and ~pop-queue~).

*** ~push-queue~

Similarly, ~push-queue~ is fairly simple to implement.

#+BEGIN_SRC clojure :results silent :exports code
  (defn push-queue [queue val]
    (swap! queue conj val)
    nil)
#+END_SRC

Then its abstract semantics:

#+BEGIN_SRC clojure :results silent :exports code
  (def push-queue-specification
    {:model/args (fn [state]
                   (gen/tuple (gen/return (:queue state))
                              gen/nat))
     :model/precondition (fn [state _] (:queue state))
     :real/command #'push-queue
     :next-state (fn [state [_ val] _]
                   (assoc state
                     :elements (conj (:elements state) val)))})
#+END_SRC

This specification has two additional elements over
~new-queue-specification~:

- ~:model/args~ specifies a function which will provide a generator to
  generate arguments for ~push-queue~. In this case we will attempt to
  push a natural number (~gen/nat~) into the queue under test (which
  we have stored in ~(:queue state)~)

- ~:model/precondition~ specifies whether this command is valid to
  run. By inspecting ~state~ and the generated arguments we may be
  able to determine that this is an invalid call. In this case: if we
  have not allocated a queue (using ~new-queue~) then it is invalid to
  try to push.

In addition to these, we can see that ~:next-state~ simply adds the
command to the end of the ~:elements~ vector in the ~state~ map.

*** ~pop-queue~

Lastly, ~pop-queue~:

#+BEGIN_SRC clojure :results silent :exports code
  (defn pop-queue [queue]
    (let [val (peek @queue)]
      (swap! queue pop)))

  (def pop-queue-specification
    {:model/args (fn [state]
                   (gen/return [(:queue state)]))
     :model/precondition (fn [state _]
                           (not (empty? (:elements state))))
     :real/command #'pop-queue
     :next-state (fn [state _ _]
                   (assoc state
                     :elements (vec (next (:elements state)))))
     :real/postcondition (fn [state _ val]
                           (= val (first (:elements state))))})
#+END_SRC

This specification has one more element from ~push-queue-specification~:

- ~:real/postcondition~ determines whether the result of performing
  this action correctly matches the expectation (from the abstract
  state). In our case: we expect the value returned by ~pop-queue~ to
  be the first value in the ~:elements~ vector.

** Running

Now we want to run our specification. In order to do this we first
need to assemble each of our command specifications into a full model
specification.

#+BEGIN_SRC clojure :results silent :exports code
  (def queue-spec
    {:commands {:new new-queue-specification
                :push push-queue-specification
                :pop pop-queue-specification}
     :generate-command (fn [state]
                         (if (nil? state)
                           (gen/return :new)
                           (gen/elements [:push :pop])))})
#+END_SRC

The ~:commands~ key just contains a map of each command spec we are
using for this model. ~:generate-command~ is a function from the
abstract state to a generator which will generate a new command.

Let's see what happens when we run this specification:

#+BEGIN_SRC clojure :results result
  (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645)
  ;; {:result false, :seed 1417059242645, :failing-size 5, :num-tests 6, :fail [[[#<0> (:new)] [#<1> (:push #<0> 4)] [#<2> (:push #<0> 2)] [#<3> (:pop #<0>)]]], :shrunk {:total-nodes-visited 5, :depth 1, :result false, :smallest [[[#<0> (:new)] [#<1> (:push #<0> 4)] [#<3> (:pop #<0>)]]]}}
#+END_SRC

Whoops! It failed! We must have a bug somewhere. Let's see if we can see that output in a nicer form.

#+BEGIN_SRC clojure :results output
  (print-test-results queue-spec (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645))
  ;; Failing test case:
  ;;    #<0> = (:new)     ;=> #<Atom@6dce3a19: #<PersistentQueue clojure.lang.PersistentQueue@1>>
  ;;    #<1> = (:push #<0> 4)     ;=> nil
  ;;    #<2> = (:push #<0> 2)     ;=> nil
  ;;    #<3> = (:pop #<0>)        ;=> #<PersistentQueue clojure.lang.PersistentQueue@21>
  ;;    !! Postcondition failed !!
  ;; Shrunk:
  ;;    #<0> = (:new)     ;=> #<Atom@7e4877a0: #<PersistentQueue clojure.lang.PersistentQueue@1>>
  ;;    #<1> = (:push #<0> 0)     ;=> nil
  ;;    #<3> = (:pop #<0>)        ;=> #<PersistentQueue clojure.lang.PersistentQueue@1>
  ;;    !! Postcondition failed !!
#+END_SRC

Okay, we seem to have an error when we create a queue, then push a
value into it, then pop the value back out. So it could be a problem
with any of our operations.

Looking at the return value of the ~:pop~ step, though, we can see
that it's returning the wrong thing! It's returning us a queue, not a
value from the queue. We have a bug!

So, let's fix our error.

#+BEGIN_SRC clojure :results silent :exports code
  (defn pop-queue [queue]
    (let [val (peek @queue)]
      (swap! queue pop)
      val))
#+END_SRC

Now let's try running our tests again.

#+BEGIN_SRC clojure :results result
  (quick-check 100 (reality-matches-model? queue-spec) :seed 1417059242645)
  ;; {:result true, :num-tests 100, :seed 1417059242645}
#+END_SRC

Success!

* Specifications

** Model specifications

A model specification is a map with two required keys:

- ~:commands~ is an array of command specifications (see below), which
  are the operations which ~stateful-check~ knows how to perform.

- ~:generate-commands~ is a function from an abstract state to a
  generator. In the interests of efficiency this function should
  attempt to create a generator which will only produce valid
  commands. A generated command is a keyword referencing a key in the
  ~:commands~ map.

** Command specifications

A command specification is a map with one required key:

- ~:real/command~ is a function to perform an operation on the real
  system.

There are six optional keys:

- ~:model/args~ is a function from state to a generator which will
  generate a vector of arguments.

- ~:model/precondition~ is a function from the state and the generated
  arguments to a value indicating whether this command is valid to run
  at this stage. If the return value of this function is falsey then
  this command is considered invalid and this sequence will not be
  run.

- ~:model/next-state~ is a function from the state, the arguments and
  an abstract result placeholder to the next state for the system.

- ~:next-state~ is a shortcut for specifying ~:model/next-state~ and
  ~:real/next-state~ to be the same function. Precedence is given to
  the more specific functions if they are present.

- ~:real/next-state~ is a function from the state, the arguments and a
  concrete result to the next state for the system.

- ~:real/postcondition~ is a function from the state, the arguments
  and a concrete result to a value indicating whether this command
  succeeded. If the return value of this function is falsey then this
  command (and hence this sequence of commands) is considered to be
  failed.

If any of these functions throw an exception it will provoke a test
failure.

* Related work

- [[https://github.com/clojure/test.check/][test.check]] (generative testing for Clojure)
- [[http://www.quviq.com/index.html][QuviQ Quickcheck]] (commercial generative testing for Erlang)
- [[http://proper.softlab.ntua.gr/index.html][PropEr]] (open source generative testing for Erlang)

* Future work

- race-condition debugging (parallel test cases)

* License

Copyright Â© 2014 Carlo Zancanaro

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
