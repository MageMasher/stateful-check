#+TITLE: stateful-check

A [[http://clojure.org][Clojure]] library designed to help with testing stateful systems with
[[https://github.com/clojure/test.check/][test.check]].

#+BEGIN_HTML
<a href="http://clojars.org/org.clojars.czan/stateful-check">
  <img src="http://clojars.org/org.clojars.czan/stateful-check/latest-version.svg"
       alt="Clojars Project">
</a>
#+END_HTML

* Example

To see an example of ~stateful-check~ to test a simple system, see the
[[file:doc/queue.org][queue example in docs/]].

* Specifications

When reading a ~stateful-check~ specification there are two main types
of keys: ~model~ and ~real~.

- ~model~ keys are ones which are keywords in the ~model~ namespace
  (that is, ~:model/X~). They deal exclusively with the abstract state
  of the system, and are only run during command generation. They
  should have no side effects. They are always provided with symbolic
  values representing the results of real commands.

- ~real~ keys are ones which are keywords in the ~real~ namespace
  (that is, ~:real/X~). They deal with the real state of the system
  and are only run during command execution. They can perform any
  side-effecting operation and are given the actual results of
  previous commands.

The distinction between the two types of keys is very important. While
values can flow from the ~model~ functions to the ~real~ functions,
they cannot flow the other way. ~model~ functions are only given
placeholders representing ~real~ values.

** Model specifications

A model specification is a map with two required keys:

- ~:commands~ is a map with values which are command specifications
  (see below). This map contains all the operations which
  ~stateful-check~ knows how to perform. The keys to this map are
  opaque to ~stateful-check~, but are used in the
  ~:model/generate-command~ function (and must be printable).

- ~:model/generate-command~ is a function from an abstract state to a
  generator. In the interests of efficiency this function should
  attempt to create a generator which will only produce valid
  commands. A generated command is a key into the ~:commands~ map.

There are six optional keys:

- ~:model/initial-state~ is a function to generate the initial state
  of the abstract system. If the spec also has a ~:real/setup~
  function then ~:model/initial-state~ will be provided with an
  argument which is a symbolic value representing the return value of
  the ~:real/setup~ function. If no ~:real/setup~ function can be
  found then ~:model/initial-state~ will be called with no arguments.

- ~:real/initial-state~ is the same as the ~:model/initial-state~
  function, except for the concrete command state. If a ~:real/setup~
  key exists then ~:real/initial-state~ will be passed the return
  value of the ~:real/setup~ function. Otherwise, it will be called
  with no arguments.

- ~:initial-state~ is a shortcut for defining both
  ~:model/initial-state~ and ~:real/initial-state~ in instances where
  the difference is irrelevant. It will be provided with either an
  abstract value or a concrete value, depending on when it is
  run. Precedence is given to the namespaced keys if they are present.

- ~:real/setup~ is a function of zero arguments which is called prior
  to any commands being run in an execution. Its return value is
  passed to the ~:real/initial-state~ function, and is available in
  symbolic form to the ~:model/initial-state~ function.

- ~:real/cleanup~ is a function of the state which can perform any
  cleanup operations required. Its return value is ignored.

- ~:real/postcondition~ is a function of the state which can perform
  general postcondition checking. This is run after each call to
  ~:real/next-state~ with the result of the transformation. This is
  intended to aid in testing things which must always be true, to
  avoid having to repeat them in each postcondition.

** Command specifications

A command specification is a map with one required key:

- ~:real/command~ is a function to perform an operation on the real
  system.

There are six optional keys:

- ~:model/args~ is a function from state to a generator which will
  generate a vector of arguments.

- ~:model/precondition~ is a function from the state and the generated
  arguments to a value indicating whether this command is valid to run
  at this stage. If the return value of this function is falsey then
  this command is considered invalid and this sequence will not be
  run.

- ~:model/next-state~ is a function from the state, the arguments and
  an abstract result placeholder to the next state for the system.

- ~:real/next-state~ is a function from the state, the arguments and a
  concrete result to the next state for the system.

- ~:next-state~ is a shortcut for specifying ~:model/next-state~ and
  ~:real/next-state~ to be the same function. Precedence is given to
  the namespaced keys if they are present.

- ~:real/postcondition~ is a function from the previous state, the
  next state, the arguments and a concrete result to a value
  indicating whether this command succeeded. If the return value of
  this function is falsey then this command (and hence this sequence
  of commands) is considered to be failed.

If any of these functions throw an exception it will provoke a test
failure.

The ~model~ namespaced keys are given an abstract state object. Any
results of commands will be opaque and abstract and the real state of
the system cannot be queried.

The ~real~ namespaced keys are given an actual, concrete state of the
system. They are only called during the actual execution of the
commands. Any results of commands will be the actual results of
running those commands.

* Related work

- [[https://github.com/clojure/test.check/][test.check]] (generative testing for Clojure)
- [[http://www.quviq.com/index.html][QuviQ Quickcheck]] (commercial generative testing for Erlang)
- [[http://proper.softlab.ntua.gr/index.html][PropEr]] (open source generative testing for Erlang)

* Future work

- race-condition debugging (parallel test cases)

* License

Copyright Â© 2014 Carlo Zancanaro

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
